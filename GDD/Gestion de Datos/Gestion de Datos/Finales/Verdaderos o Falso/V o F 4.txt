http://www.utnianos.com.ar/foro/tema-final-gestion-de-datos-v-f1.	El algoritmo quicksort siempre tiene la misma complejidad que el algoritmo de Heapsort.F. HeapSort va de O(n log n) -en el mejor de los casos- a O(n log n) -en el peor de los casos-, mientras que el Quicksort va de O(n log n) a O(n²)2.	En un árbol de expresión los nodos maximales siempre son los operadores. F. Los nodos maximales son las hojas. Y en un árbol de expresión, las hojas son los operandos, no los operadores.3.	El orden de complejidad del quicksort puede variar dependiendo de cómo vengan ordenados los datos. V En el mejor caso, el pivote termina en el centro de la lista, dividiéndola en dos sublistas de igual tamaño. En este caso, el orden de complejidad del algoritmo es O(n•log n). En el peor caso, el pivote termina en un extremo de la lista. El orden de complejidad del algoritmo es entonces de O(n²). El peor caso dependerá de la implementación del algoritmo, aunque habitualmente ocurre en listas que se encuentran ordenadas, o casi ordenadas. Pero principalmente depende del pivote, si por ejemplo el algoritmo implementado toma como pivote siempre el primer elemento del array, y el array que le pasamos está ordenado, siempre va a generar a su izquierda un array vacío, lo que es ineficiente4.	Un árbol balanceado siempre es lleno. F, para que este completo tiene que tener todas las hojas al mismo nivel, para balanceado puede ser <=1 la diferencia.5.	El orden de complejidad de en árbol b siempre es mejor que el orden de complejidad del quicksort6.	Para comprimir en el algoritmo de Huffman, se debe leer en un ciclo cada carácter del archivo a comprimir y acceder al árbol desde la raíz para llegar a la hoja que contiene el carácter. Si desciendo por un hijo izquierdo agrego un 0 como bit del código comprimido, si desciendo por un hijo derecho agregare un 1.7.	En un índice DBMS, armado en un árbol B, el tiempo de acceso a la información depende en parte del tamaño de la clave almacenada.8.	El algoritmo quicksort tiene un promedio un grado de complejidad O (n log n) pero en determinada circunstancia puede tener grade de complejidad O (n2) y ser el peor de todos los métodos de clasificación. F. Es cierto que en el peor de los casos puede tener ese grado de complejidad, pero es el mismo grado que puede tomar el Bubble sort, que es el más lento de todos. Por eso no estoy de acuerdo con que el quick sort sea el peor. 9.	El método de árbol B es más rápido que Hashing para la creación de índices. FALSO- El Hashing en la mayoria de los casos es acceso directo F(x)=y.esta es F, pero la justificacion esta mal. Fijate que habla de creacion de indices, no de accesos. En hashing es armar la tabla de hashing, en arbol B es armar toda la estructura de arbol (que si, es mas pesada)10.	Para reducir espacio al representar un grafo siempre es más conveniente la forma dinámica que estática. V. La forma dinámica se adecúa a los nodos y vertices de mi grafo, mientras que en la forma estática considero todas las potenciales ocurrencias y debo reserval tal espacio para las mismas. 11.	La reexpresion de caracteres al aplicar Huffman implica la disminución de 8 bits para la expresión de todos los caracteres.12.	La ejecución sin filas de resultado de una query dentro de un trigger genera la cancelación de la transacción. Fla unica manera de que desde el trigger canceles la transaccion es con un rollback ! o con un error13.	Siempre es conveniente tener una tabla indexada por su PK. V. Ya que es uno de los campos que más se usa en la condición Where.14.	Una constraint es más eficiente que un trigger para validar el dominio de un atributo.15.	La única forma de definir una restricción de integridad sobre una columna de una tabla es mediante la restricción CHECK. F PK y FK también sirven. F.coincido con vos, aunque también se puede utilizar Triggers para definir una restricción.16.	Debido a que el crecimiento de un árbol es exponencial en base al grado del mismo, los tiempos de búsqueda en el mismo son siempre logarítmicos.17.	El método de compresión de Huffman es sin perdida, por eso no es recomendable para compactar imágenes o video. F Es con perdido, sirve para compactar imágenes y videos. F. Sirve para compactar imagenes y video porque es SIN PERDIDA18.	En los motores de base de datos relacionales no está permitido realizar inserciones sobre una vista. F- Depende de cómo este armada la vista. F.coincido con vos. Se podría llegar a realizar inserciones sobre una vista.19.	Si un árbol esta balanceado entonces está completo. FALSOF. Porque puede tener un "hueco" y no sería completo.20.	Un árbol binario de búsqueda siempre es más rápido que una lista para ordenar un conjunto de valores. 21.	Un árbol de expresión siempre es completo. F. De hecho El ejemplo de Arbol de Expresion del apunte de Arboles no es completo: a/b + (c-d)e 22.	Luego de ejecutar una sentencia sql para crear una tabla, si se ejecuta un rollback la tabla queda dropeada. FALSO (no se necesita hacer commit para crear tabla)F. Se debería haber creado dentro de una transacción para dropearla con un rollback 23.	Si una función de hash no posee una buena dispersión, se van a producir muchas colisiones. V24.	Nunca es posible ejecutar la operación de insert sobre una vista. FALSO25.	En sql, una subconsulta ubicada en el where siempre debe retornar una fila y una columna. FALSO (en un exist o en un in puede retormar mas)claro, pero mas de una fila eh, siempre una columna26.	Un índice de base de datos relacional es una restricción al modelo físico. FALSO